# -*- coding: utf-8 -*-
"""Final_LassoRegression.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JWlz6LIW9zqU5CkdfyM7WBl1ZGf7JNGL
"""

#imports the libraries and functions needed for this notebook

import pandas as pd
import numpy as np
from sklearn.datasets import fetch_california_housing
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import Lasso
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from sklearn.model_selection import GridSearchCV
import matplotlib.pyplot as plt

#this block pulls in the housing dataset, prints out the variable names, and creates the independent & dependent variables for the next step

housing = fetch_california_housing()
print(housing.data.shape, housing.target.shape) #(20640, 8) (20640,)
print(housing.feature_names)
print(housing.target_names)

X = housing.data
y = housing.target

# Convert the data to a DataFrame for easier manipulation
df = pd.DataFrame(X, columns=housing.feature_names)

# Create the 'region' column based on the latitude (column 1 in the dataset)
df['region'] = df['Latitude'].apply(lambda x: '1' if x > 37 else '0')

# Converting back to an int:
df['region'] = df['region'].astype(int)

# Convert back into an array
X = df.to_numpy()

#Creating the training and testing data

X_train, X_test, y_train, y_test = train_test_split(X,y, test_size =.02, random_state=42)

#these functions scale the variables to make them work better for the model (I will double check the wording)

scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.fit_transform(X_test)

lasso = Lasso()
lasso.fit(X_train,y_train)

#This is the first go at the model, it is not very good at all because it is prediciting that all housing values are only $200,000. This alsoe gives the different metrics to see how the model does

y_pred = lasso.predict(X_test)

plt.scatter(y_test, y_pred)
plt.plot([min(y_test), max(y_test)], [min(y_test), max(y_test)], color='red', linestyle='--')  # Line for perfect predictions
plt.xlabel('Actual values')
plt.ylabel('Predicted values')
plt.title('Lasso Regression: Actual vs Predicted, first model')
plt.show()

mse1 = mean_squared_error(y_test, y_pred)
r2_1 = r2_score(y_test, y_pred)
print(f"MSE: {mse1} r squared: {r2_1}")

#This parameter grid will give the different alpha values we want to try for the model to improve it, then runs the lasso function through it to improve

param_grid = {
    'alpha' : [0.0001, 0.001, 0.01, 0.1, 1, 10, 100, 1000]
}

lasso_cv = GridSearchCV(lasso, param_grid, cv=3, n_jobs= -1)

#lasso_cv = Lasso(alpha=.001)

# This now takes the improved lasso model and predicts the new values for the model

lasso_cv.fit(X_train, y_train)
y_pred2 = lasso_cv.predict(X_test)

#this shows you which a value worked best for the model

lasso_cv.best_estimator_

#I am now creating a thrid model with the alpha explicilty set as .001 so we can show the impact of the variables

lasso3 = Lasso(alpha=.001)

lasso3.fit(X_train, y_train)

# Plot actual vs predicted values of the improved model
plt.scatter(y_test, y_pred2)
plt.plot([min(y_test), max(y_test)], [min(y_test), max(y_test)], color='red', linestyle='--')  # Line for perfect predictions
plt.xlabel('Actual values')
plt.ylabel('Predicted values')
plt.title('Lasso Regression: Actual vs Predicted, improved model')
plt.show()

mse2 = mean_squared_error(y_test, y_pred2)
r2_2 = r2_score(y_test, y_pred2)
print(f"MSE: {mse2} r squared: {r2_2}")

#this gives a coefficent model that shows how impactful each variable is on the price of the house.

feature_names = ['MedInc', 'HouseAge', 'AveRooms', 'AveBedrms', 'Population', 'AveOccup', 'Latitude', 'Longitude', 'region']

Variable_Coef =pd.DataFrame({'Features':feature_names, 'Coef': lasso3.coef_})

# Sort by absolute value of 'Coef' in descending order
Variable_Coef = Variable_Coef.sort_values(by='Coef', key=lambda x: x.abs(), ascending=False)

print(Variable_Coef)

print(f"Base Model - MSE: {mse1} r squared: {r2_1}")
print(f"Base Model - MSE: {mse2} r squared: {r2_2}")

# grabs the features that are not accepted by user input and pulls the means for them to make the model work

feature_indices = [feature_names.index('Population'),
                   feature_names.index('AveOccup'),
                   feature_names.index('Latitude'),
                   feature_names.index('Longitude'),
                   feature_names.index('region')]

selected_features = X[:, feature_indices]

# Calculate the mean of each feature
feature_means = np.mean(selected_features, axis=0)

# Get input from user to fill in the model
median_income = float(input("Enter median income: [ex: 60000]"))
age_of_house = float(input("Enter the preferred age of house: [ex: 10]"))
# bedrooms = int(input("Enter number of bedrooms: [ex: 3]"))
# total_rooms = int(input("Enter number of total rooms: [ex: 6]"))

while True:
    bedrooms = int(input("Enter number of bedrooms: [ex: 3]"))
    total_rooms = int(input("Enter number of total rooms: [ex: 6]"))

    # Check if the number of bedrooms is less than the total rooms
    if bedrooms >= total_rooms:
        print("Error: The number of bedrooms cannot be greater than or equal to the total rooms. Please enter again.")
    else:
        print(f"Bedrooms: {bedrooms}, Total Rooms: {total_rooms}")
        break  # Exit the loop if the condition is met

user_input = np.array([median_income, age_of_house, bedrooms, total_rooms] + list(feature_means))

# If the data was scaled during training, scale the input features using the same scaler
user_input_scaled = scaler.transform(user_input.reshape(1, -1))

# Predict house cost using the trained Lasso model (lasso3)
predicted_cost = lasso3.predict(user_input_scaled)

# Output the result
print(f"The projected cost of the house is: ${predicted_cost[0]:,.2f}")

# Install required libraries
!pip install streamlit pyngrok scikit-learn

# Import libraries
from pyngrok import ngrok
import os


name = "Testing"
# Write your Streamlit app to a file
with open("app.py", "w") as f:
    f.write("""
import pandas as pd
import streamlit as st
import numpy as np
from sklearn.datasets import fetch_california_housing
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import Lasso
from sklearn.model_selection import GridSearchCV

# Title and description
st.title(f'Predict California Housing Values')
st.write('This app uses a Lasso Regression model to predict California housing prices based on user input.')
st.write('Please Note: The California housing price prediction is based on reported data from the 1990 U.S. Census.')

# Load the California housing dataset
housing = fetch_california_housing()
X, y = housing.data, housing.target

# Convert the data to a DataFrame for easier manipulation
df = pd.DataFrame(X, columns=housing.feature_names)

# Create the 'region' column based on the latitude (column 1 in the dataset)
df['region'] = df['Latitude'].apply(lambda x: '1' if x > 37 else '0')

# If you need 'region' as a numerical column, convert it:
df['region'] = df['region'].astype(int)

# Optionally, you can convert the DataFrame back to a NumPy array:
X = df.to_numpy()

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Scale the features
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# Train the Lasso regression model
lasso = Lasso(alpha=0.1)
lasso.fit(X_train, y_train)

lasso_cv = Lasso(alpha=.001)
lasso_cv.fit(X_train, y_train)
y_pred2 = lasso_cv.predict(X_test)

lasso3 = Lasso(alpha=.001)

lasso3.fit(X_train, y_train)

feature_names = ['MedInc', 'HouseAge', 'AveRooms', 'AveBedrms', 'Population', 'AveOccup', 'Latitude', 'Longitude', 'region']

Variable_Coef =pd.DataFrame({'Features':feature_names, 'Coef': lasso3.coef_})

# Sort by absolute value of 'Coef' in descending order
Variable_Coef = Variable_Coef.sort_values(by='Coef', key=lambda x: x.abs(), ascending=False)

# User input for model features
st.sidebar.header("Input Features")
# Convert user input income to scaled format
raw_income = st.sidebar.number_input("Enter median income (e.g., 60000 for $60,000):", min_value=0.0, step=1000.0)
median_income = raw_income / 10000  # Scale income to match dataset
house_age = st.sidebar.number_input("Enter the age of the house (e.g., 10):", min_value=0.0, step=1.0)
bedrooms = st.sidebar.slider("Number of bedrooms (e.g., 3):", min_value=1, max_value=10, step=1)
bedrooms = int(bedrooms)
total_rooms = st.sidebar.slider("Number of total rooms (e.g., 6):", min_value=bedrooms, max_value=20, step=1)
total_rooms = int(total_rooms)


# Ensure total rooms > bedrooms
if total_rooms <= bedrooms:
    st.sidebar.error("Total rooms must be greater than the number of bedrooms!")

# Use the mean values for remaining features
feature_indices = [feature_names.index('Population'),
                   feature_names.index('AveOccup'),
                   feature_names.index('Latitude'),
                   feature_names.index('Longitude'),
                   feature_names.index('region')]

selected_features = X[:, feature_indices]

# Calculate the mean of each feature
feature_means = np.mean(selected_features, axis=0)

user_input = np.array([median_income, house_age, bedrooms, total_rooms] + list(feature_means))

# Scale the user input using the same scaler
user_input_scaled = scaler.transform(user_input.reshape(1, -1))
# Make predictions
predicted_price = lasso3.predict(user_input_scaled)

# Display the predicted house price
st.subheader("Predicted House Price")
st.write(f"${predicted_price[0] * 100000:.2f}")
st.subheader("Most impotant factors in buying a house")
st.write(Variable_Coef)
    """)

# Set up ngrok with your authtoken
ngrok.set_auth_token("2q4zRaoLOpHoBPRWTg9YblUX6oO_5AjBrqr2KvTwqjGNeamLZ")  # Replace with your ngrok authtoken

# Start Streamlit app
os.system("streamlit run app.py &")

# Create an ngrok tunnel to expose the app
public_url = ngrok.connect(8501)
print(f"Your Streamlit app is live at: {public_url}")

